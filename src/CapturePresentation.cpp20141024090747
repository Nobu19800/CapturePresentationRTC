// -*- C++ -*-
/*!
 * @file  CapturePresentation.cpp
 * @brief CapturePresentation Component
 * @date $Date$
 *
 * $Id$
 */

#include "CapturePresentation.h"

// Module specification
// <rtc-template block="module_spec">
static const char* capturepresentation_spec[] =
  {
    "implementation_id", "CapturePresentation",
    "type_name",         "CapturePresentation",
    "description",       "CapturePresentation Component",
    "version",           "0.1.0",
    "vendor",            "Miyamoto Nobuhiko",
    "category",          "TESTR",
    "activity_type",     "PERIODIC",
    "kind",              "DataFlowComponent",
    "max_instance",      "1",
    "language",          "C++",
    "lang_type",         "compile",
    "conf.default.windowtype", "Desktop",
    "conf.default.hertz", "8000",
    "conf.default.bits", "8",
    "conf.default.channels", "2",
    "conf.default.device_num", "-1",
    "conf.__widget__.windowtype", "radio",
    "conf.__widget__.hertz", "text",
    "conf.__widget__.bits", "radio",
    "conf.__widget__.channels", "radio",
    "conf.__widget__.device_num", "spin",
    "conf.__constraints__.windowtype", "(Desktop, ActiveWindow)",
    "conf.__constraints__.bits", "(8, 16, 32)",
    "conf.__constraints__.channels", "(1, 2)",
    "conf.__constraints__.device_num", "-1<=x<=255",
    ""
  };
// </rtc-template>

/*!
 * @brief constructor
 * @param manager Maneger Object
 */
CapturePresentation::CapturePresentation(RTC::Manager* manager)
    // <rtc-template block="initializer">
  : RTC::DataFlowComponentBase(manager),
    m_imageOut("image", m_image),
    m_soundOut("sound", m_sound)

    // </rtc-template>
{
}

/*!
 * @brief destructor
 */
CapturePresentation::~CapturePresentation()
{
}



RTC::ReturnCode_t CapturePresentation::onInitialize()
{
  // Registration: InPort/OutPort/Service
  // <rtc-template block="registration">
  // Set InPort buffers
  
  // Set OutPort buffer
  addOutPort("image", m_imageOut);
  addOutPort("sound", m_soundOut);
  
  // Set service provider to Ports
  
  // Set service consumers to Ports
  
  // Set CORBA Service Ports
  
  // </rtc-template>

  bindParameter("windowtype", windowtype, "Desktop");
  bindParameter("hertz", hertz, "8000");
  bindParameter("bits", bits, "8");
  bindParameter("channels", channels, "50");

  bSound = FALSE;

  return RTC::RTC_OK;
}

/*
RTC::ReturnCode_t CapturePresentation::onFinalize()
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t CapturePresentation::onStartup(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t CapturePresentation::onShutdown(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

bool CapturePresentation::InitWindowCapture()
{
	if(windowtype == "Desktop")
		c_window = GetDesktopWindow();
	else
		c_window = GetForegroundWindow();

	RECT rect;

	GetWindowRect(c_window, &rect);

	int width = rect.right;

	int height = rect.bottom;

	std::cout << width << "\t" << height << std::endl;

 

	/* RGB用と反転用とリサイズ用のIplImageの作成 */

	iplimage = cvCreateImageHeader(cvSize(width, height), IPL_DEPTH_8U, 3);

	flipimage = cvCreateImage(cvSize(width, height), IPL_DEPTH_8U, 3);

	

 

	/* DIBの情報を設定する */

	BITMAPINFO bmpInfo;

	bmpInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

	bmpInfo.bmiHeader.biWidth = width;

	bmpInfo.bmiHeader.biHeight = height;

	bmpInfo.bmiHeader.biPlanes = 1;

	bmpInfo.bmiHeader.biBitCount = 24;

	bmpInfo.bmiHeader.biCompression = BI_RGB;

	

 

	/* DIBSection作成 */

	LPDWORD lpPixel;

	hDC = GetDC(c_window);

	hBitmap = CreateDIBSection(hDC, &bmpInfo, DIB_RGB_COLORS, (void**)&lpPixel, NULL, 0);

	hMemDC = CreateCompatibleDC(hDC);

	SelectObject(hMemDC, hBitmap);

	ReleaseDC(c_window, hDC);

	


	/* IplImageヘッダにデータをセット */

	iplimage->imageData = (char *)lpPixel;

	return true;
}


bool CapturePresentation::ExitWindowCapture()
{
	cvReleaseImageHeader(&iplimage);

	cvReleaseImage(&flipimage);

	

	

	DeleteDC(hMemDC);

	DeleteObject(hBitmap);
	
	return true;
}


bool CapturePresentation::InitWaveCapture()
{
	WAVEFORMATEX waveForm;
	
	LPBYTE lpWaveData = NULL;

	int interval = 50;
	lpWaveData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, BUFFER_NUMBER);


	waveForm.wFormatTag = WAVE_FORMAT_PCM;
	waveForm.nChannels = channels;
	waveForm.nSamplesPerSec = hertz;
	waveForm.wBitsPerSample = bits;
	waveForm.nBlockAlign = waveForm.nChannels * waveForm.wBitsPerSample / 8;
	waveForm.nAvgBytesPerSec = waveForm.nSamplesPerSec * waveForm.nBlockAlign;
	
	
	int res = waveInOpen(&hwi, waveOutGetNumDevs()-1, &waveForm, (DWORD)this->waveInProc, 0,
                    CALLBACK_FUNCTION);
	if(res != MMSYSERR_NOERROR) return false;
	
	wvhdr_in.lpData = (LPSTR)lpWaveData;
	wvhdr_in.dwBufferLength = waveForm.nAvgBytesPerSec * interval / 1000;
	wvhdr_in.dwFlags = 0;
	wvhdr_in.reserved = 0;

	waveInPrepareHeader(hwi, &wvhdr_in, sizeof(WAVEHDR));
	waveInAddBuffer(hwi, &wvhdr_in, sizeof(WAVEHDR));
	
	WAVEOUTCAPS woc;
	MMRESULT    mmRes;

	for(int i=0;i < waveOutGetNumDevs();i++)
	{
		mmRes = waveOutGetDevCaps(i,&woc,sizeof(woc));
		std::cout << "WAVE_MAPPER" << ":" << 0  << std::endl;
		if(mmRes == MMSYSERR_NOERROR){
			std::cout << woc.szPname << ":" << i  << std::endl;
		}
	}

	bSound = TRUE;
	res = waveInStart(hwi);

	return true
}

bool CapturePresentation::ExitWaveCapture()
{
	bSound = FALSE;

	waveInStop(hwi);


	wvhdr_in.lpData = NULL;
	waveInUnprepareHeader(hwi, &wvhdr_in, sizeof(WAVEHDR));

	waveInReset(hwi);
	waveInClose(hwi);
}

RTC::ReturnCode_t CapturePresentation::onActivated(RTC::UniqueId ec_id)
{
	InitWindowCapture();



	InitWaveCapture();
	
	
	
	
	
  return RTC::RTC_OK;
}


RTC::ReturnCode_t CapturePresentation::onDeactivated(RTC::UniqueId ec_id)
{
	ExitWindowCapture();


	ExitWaveCapture();

  return RTC::RTC_OK;
}


RTC::ReturnCode_t CapturePresentation::onExecute(RTC::UniqueId ec_id)
{
	/* デスクトップから取得 */
	hDC = GetDC(desktop);
	BitBlt(hMemDC, 0, 0, width, height, hDC, 0, 0, SRCCOPY);
	ReleaseDC(desktop,hDC);



	/* 上下反転して，リサイズ */

	

	cvFlip(iplimage, flipimage);



	

	m_image.width = flipimage.width;
     	m_image.height = flipimage.height;

	int len = flipimage->nChannels * flipimage->width * flipimage->height;
	
	m_image.pixels.length(len);
	memcpy((void *)&(m_image.pixels[0]),flipimage->imageData,len);
	m_imageOut.write();
  
  


	

	
  return RTC::RTC_OK;
}

/*
RTC::ReturnCode_t CapturePresentation::onAborting(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t CapturePresentation::onError(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t CapturePresentation::onReset(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t CapturePresentation::onStateUpdate(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t CapturePresentation::onRateChanged(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

void CALLBACK CapturePresentation::waveInProc(HWAVEIN hwi, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2)
{
	LPWAVEHDR	lpwvhdr;
	char		sound_data[BUFFER_SIZE];
	int			length;

	
	
	/* フラグ制御 */
	if(bSound == FALSE) return;
	
	/* イベント処理 */
	switch(uMsg){
    	case WIM_DATA:
			
		/* キャプチャデータをバッファにコピー */
		lpwvhdr = (LPWAVEHDR) dwParam1;
		length = lpwvhdr->dwBufferLength;
		memcpy(sound_data, lpwvhdr->lpData, length);

		/* キャプチャバッファ更新 */
		waveInUnprepareHeader(hwi, lpwvhdr, sizeof(WAVEHDR));
		waveInPrepareHeader(hwi, lpwvhdr, sizeof(WAVEHDR));
		waveInAddBuffer(hwi, lpwvhdr, sizeof(WAVEHDR));

		m_sound.data.length(len);
		memcpy((void *)&(m_sound.data[0]),sound_data,length);
		m_soundOut.write();

		

		break;
	}
}



extern "C"
{
 
  void CapturePresentationInit(RTC::Manager* manager)
  {
    coil::Properties profile(capturepresentation_spec);
    manager->registerFactory(profile,
                             RTC::Create<CapturePresentation>,
                             RTC::Delete<CapturePresentation>);
  }
  
};


